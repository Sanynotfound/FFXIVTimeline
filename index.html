<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFXIVæ—¥å¿—è§£æå·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <style>
        :root {
            --apple-bg: #F5F5F7;
            --apple-text: #1D1D1F;
            --apple-gray: #86868B;
            --apple-blue: #0071E3;
            --apple-blue-hover: #0077ED;
        }

        body {
            background-color: var(--apple-bg);
            color: var(--apple-text);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.04);
        }

        .btn-primary {
            background-color: var(--apple-blue);
            color: white;
            transition: all 0.2s ease;
        }
        
        .btn-primary:hover {
            background-color: var(--apple-blue-hover);
            transform: scale(1.02);
        }
        
        .btn-secondary {
            background-color: #E8E8ED;
            color: var(--apple-text);
            transition: all 0.2s ease;
        }
        
        .btn-secondary:hover {
            background-color: #D2D2D7;
        }

        .fade-in-up {
            animation: fadeInUp 0.5s ease-out forwards;
            opacity: 0;
            transform: translateY(10px);
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* å¤åˆ¶å°å›¾æ ‡æ ·å¼ */
        .copy-icon-btn {
            opacity: 0.4;
            transition: all 0.2s ease;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
        }
        .copy-icon-btn:hover {
            opacity: 1;
            background-color: rgba(0, 113, 227, 0.1);
            color: var(--apple-blue);
        }

        /* Checkbox Custom Style */
        .custom-checkbox {
            appearance: none;
            background-color: #fff;
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.15em;
            height: 1.15em;
            border: 1px solid #d1d5db;
            border-radius: 0.25em;
            display: grid;
            place-content: center;
            transition: all 0.2s ease;
        }
        .custom-checkbox::before {
            content: "";
            width: 0.65em;
            height: 0.65em;
            transform: scale(0);
            transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em white;
            transform-origin: center;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .custom-checkbox:checked {
            background-color: var(--apple-blue);
            border-color: var(--apple-blue);
        }
        .custom-checkbox:checked::before {
            transform: scale(1);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4 sm:px-6">

    <!-- é¡¶éƒ¨æ ‡é¢˜åŒºåŸŸ -->
    <header class="w-full max-w-5xl text-center mb-8 fade-in-up" style="animation-delay: 0.1s;">
        <h1 class="text-3xl md:text-4xl font-bold tracking-tight mb-2">FFXIVæ—¥å¿—è§£æå·¥å…·</h1>
        <p class="text-[var(--apple-gray)] text-lg font-medium">ä¸Šä¼  CSV æ—¥å¿—æ–‡ä»¶ï¼Œè‡ªåŠ¨æå–å…³é”®ä¼¤å®³æ•°æ®</p>
    </header>

    <!-- ä¸»è¦æ“ä½œåŒºåŸŸ -->
    <main class="w-full max-w-5xl space-y-6">
        
        <!-- ä¸Šä¼ å¡ç‰‡ -->
        <div class="glass-card rounded-3xl p-8 text-center transition-all duration-300 hover:shadow-lg fade-in-up" style="animation-delay: 0.2s;">
            <div id="drop-zone" class="border-2 border-dashed border-gray-300 rounded-2xl p-8 cursor-pointer hover:border-[var(--apple-blue)] hover:bg-blue-50/50 transition-colors group">
                <input type="file" id="file-input" accept=".csv" class="hidden">
                <div class="flex flex-col items-center space-y-4">
                    <div class="w-16 h-16 bg-blue-100 text-[var(--apple-blue)] rounded-full flex items-center justify-center group-hover:scale-110 transition-transform">
                        <i class="ph ph-upload-simple text-3xl"></i>
                    </div>
                    <div>
                        <p class="text-lg font-semibold">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼  CSV æ–‡ä»¶</p>
                        <p class="text-sm text-[var(--apple-gray)] mt-1">æ”¯æŒæ ‡å‡†æˆ˜æ–—æ—¥å¿—æ ¼å¼</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ç»“æœæ§åˆ¶æ  -->
        <div id="control-panel" class="hidden flex flex-col gap-4 glass-card rounded-2xl p-4 fade-in-up">
            <!-- ä¸ŠåŠéƒ¨åˆ†ï¼šçŠ¶æ€ä¸æ“ä½œæŒ‰é’® -->
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4 border-b border-gray-100 pb-4">
                <div class="flex flex-col sm:flex-row items-center gap-2 sm:gap-4 text-sm text-[var(--apple-gray)]">
                    <div class="flex items-center gap-1">
                        <i class="ph ph-check-circle text-green-500 text-lg"></i>
                        <span id="status-text">è§£æå®Œæˆ</span>
                    </div>
                    <div id="player-badge" class="hidden px-2 py-0.5 bg-blue-100 text-blue-700 rounded-md font-medium text-xs">
                        ç©å®¶: <span id="player-name-display">--</span>
                    </div>
                </div>
                <div class="flex gap-3 w-full sm:w-auto">
                    <button onclick="resetAll()" class="btn-secondary flex-1 sm:flex-none px-6 py-2.5 rounded-full font-medium text-sm flex items-center justify-center gap-2">
                        <i class="ph ph-trash"></i> é‡ç½®
                    </button>
                    <button onclick="copyResults()" class="btn-primary flex-1 sm:flex-none px-6 py-2.5 rounded-full font-medium text-sm flex items-center justify-center gap-2 shadow-lg shadow-blue-500/30">
                        <i class="ph ph-copy"></i> å¤åˆ¶ç­›é€‰ç»“æœ
                    </button>
                </div>
            </div>

            <!-- ä¸‹åŠéƒ¨åˆ†ï¼šç­›é€‰å™¨ -->
            <div class="flex flex-wrap items-center gap-2 sm:gap-6 text-sm">
                <span class="font-semibold text-[var(--apple-gray)] text-xs uppercase tracking-wide">ä¼¤å®³ç­›é€‰:</span>
                
                <label class="flex items-center gap-2 cursor-pointer hover:opacity-80 transition-opacity select-none">
                    <input type="checkbox" class="custom-checkbox" value="å•æ¬¡" checked onchange="updateFilters()">
                    <span class="px-2 py-0.5 rounded text-blue-700 bg-blue-100 border border-blue-200 text-xs font-semibold">å•æ¬¡</span>
                </label>

                <label class="flex items-center gap-2 cursor-pointer hover:opacity-80 transition-opacity select-none">
                    <input type="checkbox" class="custom-checkbox" value="è¿ç»­" checked onchange="updateFilters()">
                    <span class="px-2 py-0.5 rounded text-orange-700 bg-orange-100 border border-orange-200 text-xs font-semibold">è¿ç»­</span>
                </label>

                <label class="flex items-center gap-2 cursor-pointer hover:opacity-80 transition-opacity select-none">
                    <input type="checkbox" class="custom-checkbox" value="DoTs" checked onchange="updateFilters()">
                    <span class="px-2 py-0.5 rounded text-purple-700 bg-purple-100 border border-purple-200 text-xs font-semibold">DoTs</span>
                </label>

                <label class="flex items-center gap-2 cursor-pointer hover:opacity-80 transition-opacity select-none">
                    <input type="checkbox" class="custom-checkbox" value="æ™®æ”»" checked onchange="updateFilters()">
                    <span class="px-2 py-0.5 rounded text-gray-600 bg-gray-100 border border-gray-200 text-xs font-semibold">æ™®æ”»</span>
                </label>
            </div>
        </div>

        <!-- ç»“æœé¢„è§ˆåŒºåŸŸ -->
        <div id="result-area" class="hidden glass-card rounded-3xl overflow-hidden fade-in-up shadow-xl">
            <div class="overflow-x-auto">
                <table class="w-full text-left border-collapse">
                    <thead>
                        <tr class="border-b border-gray-200 bg-gray-50/50">
                            <!-- æ—¶é—´åˆ— -->
                            <th class="p-4 text-xs font-bold uppercase tracking-wider text-[var(--apple-gray)] w-32">
                                <div class="flex items-center gap-1">
                                    æ—¶é—´
                                    <button onclick="copyColumn('time', event)" class="copy-icon-btn" title="ä»…å¤åˆ¶ç­›é€‰åçš„æ—¶é—´">
                                        <i class="ph ph-copy text-sm"></i>
                                    </button>
                                </div>
                            </th>
                            <!-- ä¼¤å®³æ¥æºåˆ— -->
                            <th class="p-4 text-xs font-bold uppercase tracking-wider text-[var(--apple-gray)]">
                                <div class="flex items-center gap-1">
                                    ä¼¤å®³æ¥æº
                                    <button onclick="copyColumn('source', event)" class="copy-icon-btn" title="ä»…å¤åˆ¶ç­›é€‰åçš„æ¥æº">
                                        <i class="ph ph-copy text-sm"></i>
                                    </button>
                                </div>
                            </th>
                            <!-- æŠ€èƒ½åç§°åˆ— -->
                            <th class="p-4 text-xs font-bold uppercase tracking-wider text-[var(--apple-gray)]">
                                <div class="flex items-center gap-1">
                                    æŠ€èƒ½åç§°
                                    <button onclick="copyColumn('skill', event)" class="copy-icon-btn" title="ä»…å¤åˆ¶ç­›é€‰åçš„æŠ€èƒ½å">
                                        <i class="ph ph-copy text-sm"></i>
                                    </button>
                                </div>
                            </th>
                            <!-- ä¼¤å®³ç±»å‹åˆ— (æ–°å¢) -->
                            <th class="p-4 text-xs font-bold uppercase tracking-wider text-[var(--apple-gray)] w-28">
                                <div class="flex items-center gap-1">
                                    ç±»å‹
                                    <button onclick="copyColumn('type', event)" class="copy-icon-btn" title="ä»…å¤åˆ¶ç­›é€‰åçš„ç±»å‹">
                                        <i class="ph ph-copy text-sm"></i>
                                    </button>
                                </div>
                            </th>
                            <!-- å®é™…ä¼¤å®³åˆ— -->
                            <th class="p-4 text-xs font-bold uppercase tracking-wider text-[var(--apple-gray)] text-right w-32">
                                <div class="flex items-center justify-end gap-1">
                                    å®é™…ä¼¤å®³
                                    <button onclick="copyColumn('damage', event)" class="copy-icon-btn mr-1" title="ä»…å¤åˆ¶ç­›é€‰åçš„æ•°å€¼">
                                        <i class="ph ph-copy text-sm"></i>
                                    </button>
                                </div>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="result-table-body" class="text-sm font-medium">
                        <!-- æ•°æ®å°†æ’å…¥è¿™é‡Œ -->
                    </tbody>
                </table>
            </div>
            <!-- ç©ºçŠ¶æ€ -->
            <div id="empty-state" class="hidden p-12 text-center text-[var(--apple-gray)]">
                <i class="ph ph-magnifying-glass text-4xl mb-2 opacity-50"></i>
                <p>æœªæ‰¾åˆ°ç¬¦åˆæ ¼å¼çš„ä¼¤å®³æ•°æ®</p>
            </div>
            <!-- ç­›é€‰åæ— æ•°æ®çŠ¶æ€ -->
            <div id="no-filter-data" class="hidden p-12 text-center text-[var(--apple-gray)]">
                <i class="ph ph-funnel-x text-4xl mb-2 opacity-50"></i>
                <p>å½“å‰ç­›é€‰æ¡ä»¶ä¸‹æ— æ•°æ®</p>
            </div>
        </div>

        <!-- ä½¿ç”¨è¯´æ˜å¡ç‰‡ -->
        <div class="glass-card rounded-2xl p-4 md:p-6 text-left w-full border border-blue-100/50 fade-in-up" style="animation-delay: 0.3s;">
            <h3 class="text-sm font-bold text-[var(--apple-blue)] uppercase tracking-wide mb-2 flex items-center gap-2">
                <i class="ph ph-info"></i> ä½¿ç”¨è¯´æ˜
            </h3>
            <ol class="list-decimal list-inside text-sm text-[var(--apple-text)] space-y-1.5 leading-relaxed">
                <li>æ‰“å¼€ <span class="font-medium bg-gray-200 px-1 rounded">fflogs.com</span>ï¼Œè¿›å…¥æˆ˜æ–—è®°å½•é¡µé¢ã€‚</li>
                <li>ç‚¹å‡» <span class="font-medium bg-gray-200 px-1 rounded">å—åˆ°ä¼¤å®³ (Damage Taken)</span> é€‰é¡¹å¡ï¼Œå¹¶åœ¨å³ä¸Šè§’é€‰æ‹© <span class="font-medium bg-gray-200 px-1 rounded">äº‹ä»¶ (Events)</span> è§†å›¾ã€‚<li>
                <li>ç­›é€‰å•åç©å®¶ã€‚<span class="text-gray-500">å»ºè®®é€‰æ‹©æ²»ç–—æˆ–è¿œæ•ç©å®¶ä½œä¸ºæ‰¿ä¼¤å‚è€ƒåŸºå‡†ã€‚</span></li>
                <li>ç‚¹å‡»é¡µé¢åº•éƒ¨çš„ <span class="font-medium bg-gray-200 px-1 rounded">CSV</span> æŒ‰é’®å¯¼å‡ºæ–‡ä»¶ã€‚å°†å¯¼å‡ºçš„ CSV æ–‡ä»¶æ‹–å…¥ä¸Šæ–¹åŒºåŸŸå³å¯è§£æã€‚</li>
                <li>å¦‚æœå¯¹å‰¯æœ¬åŠä¼¤å®³æ•°å€¼æœ‰æ„è§çš„è¯ä½ å¯ä»¥å…ˆæ”»å‡»å¤§å®¶æœ€å–œæ¬¢çš„æ¸¸æˆåˆ¶ä½œäººå‰ç”°ç›´æ ‘å’Œä¸ç“œå¡å¤«å¡ğŸŒ¹</li>
            </ol>
        </div>

    </main>

    <footer class="mt-auto py-8 text-center text-xs text-[var(--apple-gray)] opacity-60">
        <p>å‘èŠ½é»‘ç‚¹ğŸŒ± Â· æ—¥å¿—å¯èƒ½å­˜åœ¨åå·®ï¼Œè¯·ä»¥å‰¯æœ¬å†…å®é™…æ•°æ®ä¸ºå‡†ã€‚</p>
    </footer>

    <!-- Toast -->
    <div id="toast" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-2 transition-all duration-300 opacity-0 translate-y-10 z-50 pointer-events-none">
        <i class="ph ph-check-circle text-green-400 text-lg"></i>
        <span id="toast-msg" class="text-sm font-medium">æ“ä½œæˆåŠŸ</span>
    </div>

    <script>
        let parsedRows = []; // å­˜å‚¨æ‰€æœ‰è§£æåçš„æ•°æ®ï¼ˆå«typeï¼‰
        let detectedPlayerName = "";
        let knownSkills = new Set(["Combined DoTs"]);
        
        // ç­›é€‰çŠ¶æ€
        let activeFilters = new Set(["æ™®æ”»", "DoTs", "è¿ç»­", "å•æ¬¡"]);

        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const controlPanel = document.getElementById('control-panel');
        const resultArea = document.getElementById('result-area');
        const tableBody = document.getElementById('result-table-body');
        const statusText = document.getElementById('status-text');
        const emptyState = document.getElementById('empty-state');
        const noFilterData = document.getElementById('no-filter-data');
        const playerBadge = document.getElementById('player-badge');
        const playerNameDisplay = document.getElementById('player-name-display');

        // CSV è¡Œè§£æ (å¤„ç†å¼•å·)
        function parseCSVLine(text) {
            const result = [];
            let cell = '';
            let inQuotes = false;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char === '"') inQuotes = !inQuotes;
                else if (char === ',' && !inQuotes) {
                    result.push(cell); cell = '';
                } else cell += char;
            }
            result.push(cell);
            return result.map(c => c.replace(/^"|"$/g, '').trim());
        }

        // è¾…åŠ©ï¼šå°†æ—¶é—´å­—ç¬¦ä¸² "mm:ss.ms" è½¬æ¢ä¸ºç§’æ•° (float)
        function timeToSeconds(timeStr) {
            if (!timeStr) return 0;
            const parts = timeStr.split(':');
            if (parts.length !== 2) return 0;
            return parseFloat(parts[0]) * 60 + parseFloat(parts[1]);
        }

        // æ­¥éª¤1: é¢„æ‰«æ - å¯»æ‰¾ç©å®¶IDå’ŒæŠ€èƒ½åº“
        function preScanFile(lines) {
            detectedPlayerName = "";
            knownSkills = new Set(["Combined DoTs"]);
            
            const playerCounts = {};

            lines.forEach(line => {
                const cols = parseCSVLine(line);
                if (cols.length < 2) return;
                const eventStr = cols[1];

                const prepMatch = eventStr.match(/ prepares\s+(.*?)\s+on\s+(.*?)\s+\d/);
                if (prepMatch) {
                    const skill = prepMatch[1].trim();
                    const player = prepMatch[2].trim();
                    knownSkills.add(skill);
                    
                    playerCounts[player] = (playerCounts[player] || 0) + 1;
                }
            });

            let maxCount = 0;
            for (const [player, count] of Object.entries(playerCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    detectedPlayerName = player;
                }
            }
            
            console.log("Detected Player:", detectedPlayerName);
            console.log("Learned Skills:", knownSkills);
        }

        // æ­¥éª¤2: è§£æå•è¡Œ
        function parseLine(time, eventStr) {
            let rawU = 0;
            let cutIndex = -1;
            let specialStatus = null; // New: å­˜å‚¨ç‰¹æ®ŠçŠ¶æ€ (Immune/Invalid)

            const uMatch = eventStr.match(/\(U:\s*([\d,]+)/);
            const aMatch = eventStr.match(/\(A:\s*([\d,]+)/);

            if (uMatch) {
                rawU = parseInt(uMatch[1].replace(/,/g, ''), 10);
            } else if (aMatch) {
                const absorbed = parseInt(aMatch[1].replace(/,/g, ''), 10);
                const mitMatch = eventStr.match(/--(\d+)%\s+damage/);
                
                if (mitMatch) {
                    const mitigation = parseInt(mitMatch[1], 10);
                    const factor = (100 - mitigation) / 100;
                    if (factor > 0) {
                        rawU = Math.round(absorbed / factor);
                    } else {
                        rawU = absorbed;
                    }
                } else {
                    rawU = absorbed;
                }
            } else {
                // æ–°å¢ï¼šå¦‚æœæ‰¾ä¸åˆ° U/Aï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ Immune æˆ– Invalid æ ¼å¼
                if (eventStr.includes("Immune")) {
                    specialStatus = "Immune";
                } else if (eventStr.match(/--\d+%\s+damage/)) {
                    specialStatus = "Invalid";
                } else {
                    return null; // æ— æ³•è§£æçš„è¡Œ
                }
            }

            // æ¸…ç†å­—ç¬¦ä¸²ä»¥æå–æŠ€èƒ½å
            let cleanStr = "";
            
            if (uMatch || aMatch) {
                // ç°æœ‰çš„æˆªå–é€»è¾‘
                const idxU = eventStr.indexOf('(U:');
                const idxA = eventStr.indexOf('(A:');
                
                if (idxU !== -1 && idxA !== -1) cutIndex = Math.min(idxU, idxA);
                else if (idxU !== -1) cutIndex = idxU;
                else if (idxA !== -1) cutIndex = idxA;

                if (cutIndex !== -1) {
                    cleanStr = eventStr.substring(0, cutIndex).trim();
                } else {
                    cleanStr = eventStr.split('(')[0].trim();
                }
            } else {
                // ç‰¹æ®ŠçŠ¶æ€çš„æ¸…ç†é€»è¾‘
                cleanStr = eventStr;
                if (specialStatus === "Immune") {
                    cleanStr = cleanStr.replace(/Immune/g, ""); // ç§»é™¤ Immune
                }
                if (specialStatus === "Invalid") {
                    cleanStr = cleanStr.replace(/--\d+%\s+damage/g, ""); // ç§»é™¤ --30% damage
                }
                cleanStr = cleanStr.trim();
            }

            if (!detectedPlayerName) {
                const parts = cleanStr.split(/\s+/);
                const damagePart = parts.pop();
                const playerPart = parts.pop(); 
                return { 
                    time, 
                    timeSec: timeToSeconds(time), 
                    source: "Unknown", 
                    skill: "Unknown", 
                    player: playerPart, 
                    rawU, 
                    isTick: false,
                    specialStatus 
                };
            }

            if (eventStr.includes(" prepares ")) return null;

            const playerIndex = cleanStr.indexOf(detectedPlayerName);
            if (playerIndex === -1) return null;

            const leftPart = cleanStr.substring(0, playerIndex).trim();
            const rightPart = cleanStr.substring(playerIndex + detectedPlayerName.length).trim(); 

            const isTick = rightPart.startsWith("Tick");
            
            if (leftPart.includes("Multiple Enemies Combined DoTs")) {
                return {
                    time,
                    timeSec: timeToSeconds(time),
                    source: "Multiple Enemies",
                    skill: "Combined DoTs",
                    player: detectedPlayerName,
                    rawU: rawU,
                    isTick: true,
                    isCombinedSummary: true,
                    specialStatus
                };
            }

            let source = leftPart;
            let skill = "Unknown";
            let foundSkill = false;
            
            const sortedSkills = Array.from(knownSkills).sort((a, b) => b.length - a.length);
            for (const s of sortedSkills) {
                if (leftPart.endsWith(s)) {
                    skill = s;
                    source = leftPart.substring(0, leftPart.length - s.length).trim();
                    foundSkill = true;
                    break;
                }
            }

            if (!foundSkill) {
                const parts = leftPart.split(/\s+/);
                if (parts.length > 1) {
                    skill = parts.pop();
                    source = parts.join(" ");
                } else {
                    skill = leftPart;
                    source = "Unknown";
                }
            }

            return {
                time,
                timeSec: timeToSeconds(time), // å¢åŠ ç§’æ•°æ–¹ä¾¿åç»­è®¡ç®—
                source,
                skill,
                player: detectedPlayerName,
                rawU,
                isTick,
                specialStatus // è¿”å›ç‰¹æ®ŠçŠ¶æ€
            };
        }

        // æ–°å¢é€»è¾‘ï¼šåˆ†é…ä¼¤å®³ç±»å‹
        function assignDamageTypes(rows) {
            // å…ˆå¤„ç†æ˜¾å¼ç±»å‹ (æ™®æ”», DoTs)
            rows.forEach(row => {
                if (row.skill === "Combined DoTs") {
                    row.damageType = "DoTs";
                } else if (row.skill === "æ”»å‡»" || row.skill === "Attack") {
                    row.damageType = "æ™®æ”»";
                } else {
                    row.damageType = "Unknown"; // å¾…åˆ¤å®š
                }
            });

            // é’ˆå¯¹ Unknown ç±»å‹ï¼ŒæŒ‰ æŠ€èƒ½å åˆ†ç»„è¿›è¡Œæ—¶é—´èšç±»åˆ†æ
            const skillGroups = {};
            rows.forEach(row => {
                if (row.damageType === "Unknown") {
                    if (!skillGroups[row.skill]) skillGroups[row.skill] = [];
                    skillGroups[row.skill].push(row);
                }
            });

            // éå†æ¯ä¸ªæŠ€èƒ½ç»„
            for (const skillName in skillGroups) {
                const events = skillGroups[skillName];
                // ç¡®ä¿æŒ‰æ—¶é—´æ’åº (è§£ææ—¶å·²ç»æ˜¯é¡ºåºï¼Œä½†ä¸ºäº†ä¿é™©)
                events.sort((a, b) => a.timeSec - b.timeSec);

                if (events.length === 0) continue;

                // èšç±»ç®—æ³•
                let currentCluster = [events[0]];
                const clusters = [];

                for (let i = 1; i < events.length; i++) {
                    const prevEvent = currentCluster[currentCluster.length - 1];
                    const currEvent = events[i];

                    // é—´éš” <= 5s è§†ä¸ºåŒä¸€è¿ç»­ç»„
                    if ((currEvent.timeSec - prevEvent.timeSec) <= 5.0) {
                        currentCluster.push(currEvent);
                    } else {
                        // é—´éš” > 5sï¼Œç»“æŸå½“å‰ç»„ï¼Œå¼€å¯æ–°ç»„
                        clusters.push(currentCluster);
                        currentCluster = [currEvent];
                    }
                }
                clusters.push(currentCluster); // æ¨å…¥æœ€åä¸€ç»„

                // æ ‡è®°ç±»å‹
                clusters.forEach(cluster => {
                    if (cluster.length > 1) {
                        // è¿ç»­ä¼¤å®³
                        cluster.forEach(e => e.damageType = "è¿ç»­");
                    } else {
                        // å•æ¬¡ä¼¤å®³
                        cluster[0].damageType = "å•æ¬¡";
                    }
                });
            }

            return rows;
        }

        function processFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const lines = text.split(/\r?\n/).filter(line => line.trim() !== "");
                
                let startIdx = 0;
                if (lines[0] && lines[0].includes("Time")) startIdx = 1;

                const dataLines = lines.slice(startIdx);

                preScanFile(dataLines);

                if (detectedPlayerName) {
                    playerBadge.classList.remove('hidden');
                    playerNameDisplay.innerText = detectedPlayerName;
                } else {
                    playerBadge.classList.add('hidden');
                }

                let rawParsedEvents = [];
                dataLines.forEach(line => {
                    const cols = parseCSVLine(line);
                    if (cols.length < 2) return;
                    const parsed = parseLine(cols[0], cols[1]);
                    if (parsed) rawParsedEvents.push(parsed);
                });

                // å¤„ç† DoT åˆå¹¶é€»è¾‘
                let processedEvents = processGroups(rawParsedEvents);
                
                // å¤„ç†ä¼¤å®³ç±»å‹åˆ†ç±»é€»è¾‘
                parsedRows = assignDamageTypes(processedEvents);
                
                renderTable();
            };
            reader.readAsText(file, 'UTF-8');
        }

        function processGroups(events) {
            const output = [];
            const groups = {}; 
            
            events.forEach(ev => {
                if (!groups[ev.time]) groups[ev.time] = [];
                groups[ev.time].push(ev);
            });

            const uniqueTimes = [...new Set(events.map(e => e.time))];

            uniqueTimes.forEach(time => {
                const groupEvents = groups[time];
                const summaryEvent = groupEvents.find(e => e.isCombinedSummary);

                if (summaryEvent) {
                    let totalU = 0;
                    groupEvents.forEach(e => {
                        if (!e.isCombinedSummary && e.isTick) {
                            totalU += e.rawU;
                        }
                    });

                    const finalU = totalU > 0 ? totalU : summaryEvent.rawU;
                    
                    // é€»è¾‘ï¼šå¦‚æœæœ€ç»ˆä¼¤å®³ä¸º0ä¸”Summaryæœ‰ç‰¹æ®ŠçŠ¶æ€ï¼Œåˆ™æ˜¾ç¤ºç‰¹æ®ŠçŠ¶æ€
                    let displayDmg = `${finalU}`;
                    if (finalU === 0 && summaryEvent.specialStatus) {
                        displayDmg = summaryEvent.specialStatus;
                    }

                    output.push({
                        time: time,
                        timeSec: timeToSeconds(time),
                        source: "Multiple Enemies",
                        skill: "Combined DoTs",
                        displayDamage: displayDmg,
                        rawU: finalU,
                        specialStatus: summaryEvent.specialStatus
                        // ç±»å‹å°†åœ¨åç»­æ­¥éª¤åˆ†é…
                    });

                    groupEvents.forEach(e => {
                        if (!e.isCombinedSummary && !e.isTick) {
                            output.push({
                                time: e.time,
                                timeSec: e.timeSec,
                                source: e.source,
                                skill: e.skill,
                                displayDamage: e.specialStatus ? e.specialStatus : `${e.rawU}`,
                                rawU: e.rawU,
                                specialStatus: e.specialStatus
                            });
                        }
                    });

                } else {
                    groupEvents.forEach(e => {
                        output.push({
                            time: e.time,
                            timeSec: e.timeSec,
                            source: e.source,
                            skill: e.skill,
                            displayDamage: e.specialStatus ? e.specialStatus : `${e.rawU}`,
                            rawU: e.rawU,
                            specialStatus: e.specialStatus
                        });
                    });
                }
            });

            return output;
        }

        function formatTimeDisplay(timeStr) {
            if (!timeStr) return "";
            return timeStr.split('.')[0];
        }

        function getDamageTypeStyle(type) {
            switch(type) {
                case 'å•æ¬¡':
                    // ä¿®æ”¹ï¼šä»çº¢è‰²æ”¹ä¸ºè¾ƒæŸ”å’Œçš„è“è‰²
                    return 'bg-blue-50 text-blue-600 border-blue-200';
                case 'è¿ç»­':
                    return 'bg-orange-100 text-orange-700 border-orange-200';
                case 'DoTs':
                    return 'bg-purple-100 text-purple-700 border-purple-200';
                case 'æ™®æ”»':
                    return 'bg-gray-100 text-gray-600 border-gray-200';
                default:
                    return 'bg-gray-50 text-gray-500 border-gray-100';
            }
        }

        function updateFilters() {
            activeFilters.clear();
            const checkboxes = document.querySelectorAll('.custom-checkbox');
            checkboxes.forEach(cb => {
                if (cb.checked) activeFilters.add(cb.value);
            });
            renderTable();
        }

        function renderTable() {
            tableBody.innerHTML = '';
            
            if (parsedRows.length === 0) {
                controlPanel.classList.remove('hidden');
                resultArea.classList.remove('hidden');
                emptyState.classList.remove('hidden');
                noFilterData.classList.add('hidden');
                statusText.innerText = "æœªæ‰¾åˆ°ç¬¦åˆçš„æ•°æ®";
                return;
            }

            const visibleRows = parsedRows.filter(row => activeFilters.has(row.damageType));

            controlPanel.classList.remove('hidden');
            resultArea.classList.remove('hidden');
            emptyState.classList.add('hidden');
            
            if (visibleRows.length === 0) {
                noFilterData.classList.remove('hidden');
                statusText.innerText = `ç­›é€‰ç»“æœ: 0 / ${parsedRows.length} æ¡`;
            } else {
                noFilterData.classList.add('hidden');
                statusText.innerText = `æ˜¾ç¤º ${visibleRows.length} æ¡ (å…± ${parsedRows.length} æ¡)`;
            }

            visibleRows.forEach(row => {
                const tr = document.createElement('tr');
                tr.className = "border-b border-gray-100 hover:bg-blue-50/30 transition-colors";
                const displayTime = formatTimeDisplay(row.time);
                const typeStyle = getDamageTypeStyle(row.damageType);
                
                // å¤„ç†ç‰¹æ®Šä¼¤å®³æ˜¾ç¤ºçš„æ ·å¼
                let damageTextClass = "text-[var(--apple-text)]";
                if (row.displayDamage === "Immune") {
                    damageTextClass = "text-red-800 font-bold";
                } else if (row.displayDamage === "Invalid") {
                    damageTextClass = "text-gray-400 italic";
                }

                tr.innerHTML = `
                    <td class="p-4 text-[var(--apple-text)] tabular-nums">${displayTime}</td>
                    <td class="p-4 text-[var(--apple-text)] font-medium">${row.source}</td>
                    <td class="p-4 text-[var(--apple-text)]"><span class="bg-gray-100 px-2 py-1 rounded text-xs text-gray-600">${row.skill}</span></td>
                    <td class="p-4 text-[var(--apple-text)]">
                        <span class="px-2 py-1 rounded text-xs font-semibold border ${typeStyle}">
                            ${row.damageType}
                        </span>
                    </td>
                    <td class="p-4 ${damageTextClass} text-right font-bold tabular-nums">${row.displayDamage}</td>
                `;
                tableBody.appendChild(tr);
            });
        }

        function copyColumn(type, event) {
            if(event) event.stopPropagation();

            const visibleRows = parsedRows.filter(row => activeFilters.has(row.damageType));
            
            if (visibleRows.length === 0) {
                showToast("æ²¡æœ‰å¯è§æ•°æ®å¯å¤åˆ¶", "error");
                return;
            }

            let text = "";
            visibleRows.forEach(row => {
                let content = "";
                switch(type) {
                    case 'time':
                        content = formatTimeDisplay(row.time);
                        break;
                    case 'source':
                        content = row.source;
                        break;
                    case 'skill':
                        content = row.skill;
                        break;
                    case 'type':
                        content = row.damageType;
                        break;
                    case 'damage':
                        content = row.displayDamage;
                        break;
                }
                text += `${content}\n`;
            });

            performCopy(text, `å·²å¤åˆ¶ç­›é€‰åçš„${type === 'time' ? 'æ—¶é—´' : type === 'source' ? 'æ¥æº' : type === 'skill' ? 'æŠ€èƒ½å' : type === 'type' ? 'ç±»å‹' : 'ä¼¤å®³å€¼'}åˆ—`);
        }

        function performCopy(text, successMsg) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast(successMsg);
            } catch (err) {
                showToast("å¤åˆ¶å¤±è´¥", "error");
            }
            document.body.removeChild(textarea);
        }

        function copyResults() {
            const visibleRows = parsedRows.filter(row => activeFilters.has(row.damageType));

            if (visibleRows.length === 0) {
                showToast("æ²¡æœ‰å¯è§æ•°æ®å¯å¤åˆ¶", "error");
                return;
            }
            let text = "æ—¶é—´\tä¼¤å®³æ¥æº\tæŠ€èƒ½åç§°\tä¼¤å®³ç±»å‹\tå®é™…ä¼¤å®³\n";
            visibleRows.forEach(row => {
                text += `${formatTimeDisplay(row.time)}\t${row.source}\t${row.skill}\t${row.damageType}\t${row.displayDamage}\n`;
            });

            performCopy(text, "å·²å¤åˆ¶ç­›é€‰ç»“æœ");
        }

        function resetAll() {
            parsedRows = [];
            detectedPlayerName = "";
            fileInput.value = '';
            controlPanel.classList.add('hidden');
            resultArea.classList.add('hidden');
            playerBadge.classList.add('hidden');
            
            // é‡ç½®ç­›é€‰
            const checkboxes = document.querySelectorAll('.custom-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
            activeFilters = new Set(["æ™®æ”»", "DoTs", "è¿ç»­", "å•æ¬¡"]);
        }

        // Event Listeners
        if (dropZone && fileInput) {
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) processFile(e.target.files[0]);
            });
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('bg-blue-50', 'border-[var(--apple-blue)]');
            });
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('bg-blue-50', 'border-[var(--apple-blue)]');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('bg-blue-50', 'border-[var(--apple-blue)]');
                if (e.dataTransfer.files.length > 0) processFile(e.dataTransfer.files[0]);
            });
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const msg = document.getElementById('toast-msg');
            const icon = toast.querySelector('i');
            msg.innerText = message;
            if (type === 'error') icon.className = 'ph ph-warning-circle text-red-400 text-lg';
            else icon.className = 'ph ph-check-circle text-green-400 text-lg';
            
            toast.classList.remove('opacity-0', 'translate-y-10');
            setTimeout(() => toast.classList.add('opacity-0', 'translate-y-10'), 2500);
        }
    </script>
</body>
</html>
